# Clean Code Summary

<div style="text-align: right">20180740 염재후</div>

# Chapter 2. 의미있는 이름

이 챕터에서 강조하는것은 "이름"이다. 코딩에서 이름은 단순히 사람이 보는 변수를 구분하는 방법이지만, 실제 개발에서는 어떤 이름을 가지는지에 따라 천차만별의 효율을 지니게 된다. 그 이유는 사용해야 하는 변수의 이름의 양이 매우 많기 때문이다.

## 변수에 분명한 의도를 담자

컴퓨터 공학과의 가장 기초적인 수업, CSED101의 어싸인을 하다가, 다른 사람들의 에러를 찾아주기 위해 코드를 보면 매우 이해하기 어렵다. 크게는 프로그램의 구조, 작게는 함수의 역할이나 변수가 담고있는 값에 대해서 알아야 한다.

가장 흔하게 볼 수 있는 변수는

```c++
int sum;
int d;
int cnt;
```

같은 종류이다. `int sum;`의 경우는 그래도 어떤 값의 합이라는 의미를 담고 있지만, `int d;` 혹은 `int cnt;`는 어떤 값을 담고 있는지 짐작하기 쉽지 않다. 따라서 <u>어떤 값을 가지고 있는지 이름에 정보를 담아주면, 변수에 대한 정보를 찾기 위해 별도의 시간을 들이지 않아도 될 것이다.</u>

e.g.

```c++
int sumOfUsedMoney;
int elapsedTimeInDays;
int numberOfClickedInPage;
```

## 적절하고 의미있는 정보를 담자

`int sum`와 `int sumOfUsedMoney`를 비교해 봤을 때, 변수에 대한 많은 정보를 주기 위해, 더 긴 이름은 당연해보인다. 하지만, 더 많은 정보를 주는 것은 좋지만, 부정확하거나, 사용자가 헷갈릴만한 정보를 넣어서는 안된다.

### 적절하지 않은 경우

물리적으로 헷갈리기 쉬운 이름이나, 이름의 의미가 적절치 않은 경우를 이야기한다. 

물리적으로 헷갈리기 쉬운 경우는 `XYZControllerForEfficientHandling`이라는 변수와 `XYZControllerForFastHandling`를 예시로 들 수 있다. 굉장히 길지만, 중간의 짧은 부분만이 서로 다르다. 자세히 읽으면 다른 것을 알지만, 한눈에 들어오지는 않는다.

`accountList`라는 이름의 변수의 경우, 이 변수가 `list` 컨테이너를 사용해서 list가 붙은 건지 아니면, bunch of account를 표현하고 싶은 것인지 헷갈릴 수 있다. 이런 경우는 `accountGroup`, `bunchOfAccount`등의 이름으로 사용할 수 있다. 

이러한 경우는 정보를 많이 담았지만, 적절치 않은 정보를 담았다고 할 수 있다.

### 의미가 혼동되는 경우

어떠한 웹 서비스에서 계정의 정보를 얻고자 할 때 아래의 세 개 중 어떤 함수를 써야할까?

```c++
Account getAccount();
Account getAccountInfo();
Account getAccountDetail();
```

앞서 설명한 물리적으로 헷갈리기 쉬운 것과는 다르게 의미적으로 헷갈리는 경우이다. 이러한 경우를 막기 위해 변수/함수의 이름을 지을 때, 다른 변수/함수의 이름도 고려하도록 하자

## 발음/검색이 쉬운 이름이 더 좋다

이름이 적절한 의미를 담고 있는 것은 중요하다. 하지만, 그 이름이 발음하기도 쉽고 검색하기도 쉽다면 더욱 좋을 것은 당연하다. 발음하기 쉽다면, 다른 co-worker와 의견을 나누는데 편리할 것이고, 검색이 쉽다면, 해당 변수/함수에 대한 이해나 수정이 배로 편햊리 것이다.

## 더 좋은 이름을 짓기 위한 조언!

### 클래스 이름

명사, 혹은 명사구가 적합하다. 대신 너무 흔한 이름은 피한다(e.g. Manager, Data, Info ..etc)

### 메소드 이름

동사, 혹은 동사구가 적합하다. 특히 Accessor, Mutator, Predicate는 get, set, is로 시작하는 편이 적합하다.

### 한 개념에 한 단어를 사용하자

Accessor에서 get/acquire/bring 등등 비슷한 의미를 가지는 다양한 단어를 채택한다면, 아마 사용자는 다른 의미가 있는지 파악해야만 할 것이다. 만약 다른 의미가 있다면 다행이지만, 일관되지 않게 혼용된다면 아마 수많은 시간을 이 단어들을 구분짓는데 사용할 것이다.

가장 좋은 것은 한 개념에 한 단어만을 사용하는 것이다.

# Chapter 3. 함수

프로그램은 함수로 이뤄져 있다. 따라서 깔끔한 함수와 그 활용은 중요하다. 이번 챕터에서 가장 강조하는 것은 <u>짧고, 한 가지만 하는</u> 함수이다.

## 짧은 함수

이 책에서는 한 함수가 2~3줄로 이뤄지기를 권장하고 있다. 내 생각에는 2~3줄은 극단적일 정도로 짧은 정도라고 생각한다. 하지만, 짧은 함수가 더 좋다는 것은 부정할 수 없는 사실이다.

## 한 가지만 하는 함수

함수가 여러 가지 일을 같이 처리한다면, 높은 확률로 해당 함수는 복잡해질 것이다. 즉, 짧아질 수 없을 뿐더러 이해하기 어려워질 것이다. 또한 에러가 났을 경우, 고치기가 어려워질 것이다. 에러가 함수 안의 다른 기능들에 영향을 미칠 가능성이 높기 때문이다.

## 추상화?

위의 두 가지 설명을 보면, 함수가 한 가지만 할 때, 짧고 이해가 잘 되는 함수라고 생각할 수 있다. 그렇다면, 한 가지는 어떻게 정의하는 것일까? 그 해답이 바로 **추상화**이다. 

추상화의 수준이 하나라면, 그 함수는 한 가지 일을 하는 함수라고 말할 수 있다.

추상화의 수준이 하나인 것을 확인하기 위해서는 TO 문단 기술법을 사용해보도록 하자.

> TO문단 기술법: LOGO언어의 함수 기술법
>
> TO (Our purpose), Do Something(e.g. Check Condition, if true Do A, else Do B)

만약 TO 문단이 간단하게 기술되는 경우, 추상화의 수준이 하나라고 할 수 있다.

단, 이것으로 전부는 아니다. 함수 내부는 추상화가 비슷한 함수들로 이뤄져야 한다. HTML 페이지로 렌더링하는 함수 안에서 HTML 페이지 안에 들어갈 수식의 형식을 증명하는 것처럼 어울리지 않는 추상화가 섞일 경우, 함수를 디자인하는데 많은 어려움이 나올 것이다. 또한 그런 혼란한 예시가 하나 생기는 경우, 다른 함수들 마저도 이와 비슷하게 설계될 수 있는 가능성이 생기기 때문에 최대한 추상화의 수준을 고려해서 함수를 설계하는 것이 중요하다.

### 추상화를 잘하기 위해서

앞서, 추상화의 수준을 파악하기 위해 TO 문단을 사용했다. 그리고 이 TO 문단을 사용해서 추상화의 수준을 파악할 수 있다

TO A

​	To A-1

​		To A-1-1

​	To A-2

​		To A-2-1

와 같이 들여쓰기 방식으로 TO 문단이 들어갈 수 있다면, 추상화의 수준을 구분하는데 더 쉬울 것이다.

## 함수의 인수

함수의 인수는 무항/단항을 추천한다고 한다. 인수가 함수와 어떤 방식으로 서로 작용하는지 불확실할 뿐더러, 인수가 많아지는 경우, 그 순서나 인수간 관계 역시 불확실해지기 때문이다.

특히, 단항함수의 경우, 출력인수를 입력 인수로 넣는 것은 굉장히 어색하다. 

```C++
void addFooter(std::String a);
```

`addFooter`함수는 a에 Footer를 추가하는 것인지, a가 Footer로 들어가는 것인지 헷갈린다. 이와 같은 경우를 조심해야 하며, 이런 경우 OOP style이 도움이 될 수 있다.

```C++
page.addFooter(a);
```

와 같은 작성은 분명하게 a가 footer로 들어가는 것을 알 수 있기 때문이다.

## 오류코드 대신 예외처리!

오류가 날 수 있는 경우 조건문을 통해서 걸러내기 보다는 예외처리를 하는 것이 훨씬 그 의도를 잘 드러낸다. 조건문을 통한 서술은 자칫하면 에러가 아닌 하나의 경우로 바라보게 될 수 있기 때문이다.

결국 try/catch를 쓰게 되는데, 이 경우에는 당연히 하나의 함수로 만들어서 처리해아 한다.(예외처리도 <u>하나</u>의 작업이기 때문이다.)

## 함수를 잘 짜기 위해서!

### 중복을 제거하자!

나는 가끔씩 함수를 디자인 할 때, 많이 안 쓸 것 같다는 생각에 새로운 함수를 만드는 것이 옳을까 하는 생각을 하곤 한다. 하지만, 함수를 짜는 이유는 결국 중복을 줄이기 위해서이고, 좀 더 높은 추상화 레벨에서의 코딩이 인간친화적이기 때문이다. 따라서, 중복되거나 알아보기 힘든 작업들은 나눠서 함수로 만들도록 하자.

그러한 작업들은 결국, 하위 함수를 잘 짜게 해서 상위 함수들을 만드는데 도움이 된다.

### 어떻게 디자인하는가?

우리는 좋은 글을 쓰기 위해서 몇 번이고 퇴고를 거듭한다. 코딩 역시 마찬가지이다. 투박하게라도 옳은 작업을 하는 함수를 짜고, 단위 테스트를 구현한다. 이후에 다시 읽으면서 중복되는 부분을 줄이고, 인수를 줄이며 함수를 다시 써나간다. 이 과정에서 함수가 올바른 일에 동작하는지 단위 테스트를 사용해서 확인해야 한다. 이 과정을 거친다면, 충분히 좋은 함수가 나올 것이다. 


# Chapter 4. 주석
주석은 매우 신경써서 써야한다. 틀린 정보를 담고 있거나, 조금만 misleading하는 의미를 담고 있어도 큰 영향을 미치기 때문이다.

사람들은 아마 주석과 코드 사이에서 어떤 것을 믿어야할지 고민할 것이다. 혹은 자신의 이해력을 의심하게 될지도 모른다.

주석에 신경 쓸 시간을 코드에 더 할양하는 것이 때로는 정해가 될 수도 있다. 굉장히 로우 리턴 하이 리스크인 작업이라고 할 수 있다.

그럼에도 불구하고 주석을 쓰는 이유는
1. 코드에는 담지 못하는 의사 결정 과정, 디테일한 설명을 적을 수 있다.
2. 코드보다 human-friendly하다.

이기 때문이다.

그 중 가장 주석에서 쓰기 좋은 용도는 TODO 주석 혹은 저작권에 대한 주석이다.

저작권은 필요에 의해서 적는 경우가 대다수이다.

하지만 TODO의 경우, 작업을 마치기 전, 다음날의 나에게, 혹은 다른 작업자들을 위해 현재 상태, 해야할 일들을 상세하게 설명한다면, 아마 그 다음 작업자들은 내가 어떤 생각을 가지고 코딩을 했는지 그대로 이해하고, 같은 마음인 것처럼 코딩할 수 있을 것이다.(당연하게도, 상세한 것과 단순히 긴 것은 다른 것을 기억하자!)

아래의 리스트는좋은 주석을 위해서, 주석을 쓰기 전에 다시 한 번 생각해볼만한 것이다.
1. 코드로 표현할 수 있지 않을까?
2. 정말 필요한가? 
3. 의도를 분명하게 드러내는가?
4. 옳은 정보를 담고 있는가?
5. 코드를 주석으로 남기지 말것!

# Chapter 7. Error Handling
예외는 코드를 깔끔하게 하는 좋은 방법 중 하나이다.

대부분, 예외처리는 코드에 안정성을 부여하는 방법으로 알고 있을 것이다. 하지만, 예외처리는 코드를 깔끔하게 하는 방법이기도 하다.

예외처리를 하게 되면, 기능 알고리즘과 예외를 처리하는 알고리즘을 분리해서 구현하게 된다.

개념적으로도, 분리가 되기 때문에 이해하기 깔끔해지며, 구현하기도 쉬워진다.

단, 예외도 똑똑하게 해야한다. 어떤 방법이 똑똑한 방법일까?

1. Unchecked Error를 주로 사용할 것!

    why?
    - Checked Error의 경우, 예외 타입을 정해줘야한다. 이는 후에 Error가 추가되거나, 수정될 경우, Open-Closed Principle을 위반한다.
    - 더욱이, 어떤 Error가 일어났는지 최하단의 함수가 알아야 하기 때문에 Encapsulation이 깨진다.
    - Checked Error는 각 타입별로 예외를 처리하는 코드를 반드시 작성해야 하기 때문에, 코드가 지저분해진다.

2. 예외에 의미를 담자!

    why?
    - 전후사정을 비롯한 정보를 담게 되면, 이후 예외가 일어난 상황을 이해하기 위해 코드를 뒤적이지 않아도 된다.
    - 더욱이, 어디서 예외가 일어났는지도 빠르게 확인할 수 있다.

3. 외부 API를 사용하는 경우 Wrapper Class를 사용할 것!
  
  Why?
    - Open Closed Principle을 준수할 수 있다.(한 번에 한 곳만 수정하면 된다!)
    - 외부 API에 대한 Dependency를 줄일 수 있다.

꺠끗한 코드와 안정적인 코드는 서로 다른 지향점을 가지고 있지 않다는 것을 이해해야 한다.

예외처리가 잘 된다는 것은 기능이 기능만 잘 작동하게 하면 된다는 것이기 때문이다.
그 과정중에서 코드 역시 더 안정적으로 작동하게 된다.










